// // // 变量对象的创建过程的三条规则：
// // // 建立arguments对象。检查当前执行上下文中的参数，建立该对象下的属性与属性值。
// // // 检查当前执行上下文的函数声明，也就是使用function关键字声明的函数。

// // // 在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。
// // // 如果该属性之前已经存在，那么该属性将会被新的引用所覆盖。

// // // 检查当前执行上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。
// // // 如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。
// // //-------------------------------------------><---------------------------------------
// function fn(a, b) {
//   console.log(a)
//   var a = 'fna'
// }
// fn() //undefined

// function fn(a, b) {
//   console.log(a)
//   var a = 'fna'
// }
// fn('a') //a
// // //-------------------------------------------><---------------------------------------
// //执行上下文在创建变量对象时，对使用function声明和var表达式声明的函数 处理不一样
// // var a = function () { } 会做两件事  
// //1、在执行上下文创建时var a 变量提升，a = undefiend 
// //2、执行到本条语句时，赋值  a = function () {} 
// function fn() {
//   console.log(a)
//   function a() { }
// }
// fn() //[Function: a]

// function fn() {
//   console.log(a)
//   var a = function () { }
// }
// fn() //undefined
//   //-------------------------------------------><---------------------------------------
//   // 下面代码展示的是 使用function关键字声明的函数。会覆盖旧的属性（形参ff）。
//   (function (ff) {
//     console.log(ff)
//     function ff() {
//     }
//   })('ffff') // [Function: ff]

//   (function (ff) {
//     console.log(ff)
//     var ff = 'var不会覆盖'
//   })('ffff') // ffff


// 代码迷惑大赏
//-------------------------------------------><---------------------------------------

func() //此时上下文创建阶段时已经处理过了func的函数提升， func引用到函数对象，输出 >> function func
function func() {
  console.log('function func');
}
var func = 'dd'
console.log(func);  // 到这里执行上下文执行阶段
//按理来说，var声明的func遇到函数声明过的func会跳过，但是此时函数声明的func被覆盖了，输出 >> dd
//这是因为三条规则（var func）仅仅适用执行上下文的创建阶段。而func = 'dd' 是在上下文执行阶段中运行的

//总结一下var的缺点
//1、变量提升、允许重复声明  "依靠"它们可以写出迷惑心智、令人费解的程序
//2、污染环境 for循环里var声明的变量在循环结束后依然存在

// 决定this指向对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。
//-------------------------------------------><---------------------------------------

function func() {
  console.log(this.a);
}
var a = 2;
var o = { a: 3, func: func };
var p = { a: 4 };
o.func(); //>> 3
(p.func = o.func)(); //>> 2
// 赋值表达式 p.func=o.func 的返回值是目标函数的引用，也就是 func 函数的引用
// 因此调用位置是 func() 而不是 p.func() 或者 o.func()


作用域链 多个作用域对应的变量串联起来组成的链表
{
  "scope": [
    {
      实参,
      形参,
      函数,
      变量
    },
    {
      实参,
      形参,
      函数,
      变量
    }
  ]
}

