//JavaScript 基于词法作用域查找变量，执行到foo()时，foo 在全局定义的，所以输出2
function foo() {
  console.log(a); // 2
}
function bar() {
  var a = 3;
  foo();
}
var a = 2;
bar();

//JavaScript 执行到foo()时，foo 在bar()函数的作用域定义的，所以输出3
function bar() {
  var a = 3;
  foo();
  function foo() {
    console.log(a); // 3
  }
}
var a = 2;
bar();

// ##定义
// 内层的作用域访问它外层函数作用域里的参数/变量/函数时，闭包就产生了
// 在Chrome开发工具里 Closure出现在Scope一栏里面，所以可以认为闭包也是一种作用域 

// 既然闭包也是一种作用域，闭包能够解决经典的“循环中的闭包”的问题，
// 那是不是利用作用域就能解决问题？想到了关键字let

// 闭包是一种作用域，它拷贝了一套外层函数作用域中被访问的参数、变量/函数，这个拷贝都是浅拷贝

// ##闭包好处：
// 这样可以实现软件设计上的封装，设计出很强大的类库、框架，比如我们常用的jQuery、AngularJS、Vue.js。

// ##闭包缺点：
// javascript中的垃圾回收（GC）规则是这样的：如果对象不再被引用，
// 或者对象互相引用形成数据孤岛后且没有被孤岛之外的其他对象引用，那么这些对象将会被JS引擎的垃圾回收器回收
// ；反之，这些对象一直会保存在内存中。

// 由于闭包会引用包含它的外层函数作用域里的变量/函数，因此会比其他非闭包形式的函数占用更多内存。
// 当外层函数执行完毕退出函数调用栈（call stack）的时候，
// 外层函数作用域里变量因为被引用着，可能并不会被JS引擎的垃圾回收器回收，
// 因而会引起内存泄漏。过度使用闭包，会导致内存占用过多，甚至内存泄漏。

//## 使用场景
// 循环中的闭包 模块封装